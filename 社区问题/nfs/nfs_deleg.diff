diff --git a/fs/nfs/callback_proc.c b/fs/nfs/callback_proc.c
index bfdd21224073..05b3cc79db54 100644
--- a/fs/nfs/callback_proc.c
+++ b/fs/nfs/callback_proc.c
@@ -77,6 +77,7 @@ __be32 nfs4_callback_recall(void *argp, void *resp,
 	struct inode *inode;
 	__be32 res;
 	
+	printk("%s get callback recall\n", __func__);
 	res = htonl(NFS4ERR_OP_NOT_IN_SESSION);
 	if (!cps->clp) /* Always set for v4.0. Set in cb_sequence for v4.1 */
 		goto out;
diff --git a/fs/nfs/delegation.c b/fs/nfs/delegation.c
index 3ba1c8fc43d8..0e304755915b 100644
--- a/fs/nfs/delegation.c
+++ b/fs/nfs/delegation.c
@@ -492,6 +492,7 @@ int nfs_inode_set_delegation(struct inode *inode, const struct cred *cred,
 	if (freeme == NULL)
 		goto out;
 add_new:
+	printk("%s add dp %px to delegations\n", __func__, delegation);
 	list_add_tail_rcu(&delegation->super_list, &server->delegations);
 	rcu_assign_pointer(nfsi->delegation, delegation);
 	delegation = NULL;
@@ -1202,6 +1203,7 @@ static void nfs_mark_test_expired_delegation(struct nfs_server *server,
 		return;
 	clear_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags);
 	set_bit(NFS_DELEGATION_TEST_EXPIRED, &delegation->flags);
+	printk("%s set NFS_DELEGATION_TEST_EXPIRED for dp %px\n", __func__, delegation);
 	set_bit(NFS4CLNT_DELEGATION_EXPIRED, &server->nfs_client->cl_state);
 }
 
@@ -1278,6 +1280,7 @@ static int nfs_server_reap_expired_delegations(struct nfs_server *server,
 	struct inode *inode;
 	const struct cred *cred;
 	nfs4_stateid stateid;
+	printk("%s start\n", __func__);
 restart:
 	rcu_read_lock();
 	list_for_each_entry_rcu(delegation, &server->delegations, super_list) {
@@ -1296,19 +1299,23 @@ static int nfs_server_reap_expired_delegations(struct nfs_server *server,
 		nfs4_stateid_copy(&stateid, &delegation->stateid);
 		spin_unlock(&delegation->lock);
 		clear_bit(NFS_DELEGATION_TEST_EXPIRED, &delegation->flags);
+		printk("%s clear NFS_DELEGATION_TEST_EXPIRED for deleg %px\n", __func__, delegation);
 		rcu_read_unlock();
 		nfs_delegation_test_free_expired(inode, &stateid, cred);
 		put_cred(cred);
 		if (!nfs4_server_rebooted(server->nfs_client)) {
 			iput(inode);
 			cond_resched();
+			msleep(5000);
 			goto restart;
 		}
 		nfs_inode_mark_test_expired_delegation(server,inode);
 		iput(inode);
+		printk("%s end\n", __func__);
 		return -EAGAIN;
 	}
 	rcu_read_unlock();
+	printk("%s end\n", __func__);
 	return 0;
 }
 
diff --git a/fs/nfs/nfs4renewd.c b/fs/nfs/nfs4renewd.c
index ff876dda7f06..8990a98e4909 100644
--- a/fs/nfs/nfs4renewd.c
+++ b/fs/nfs/nfs4renewd.c
@@ -72,7 +72,7 @@ nfs4_renew_state(struct work_struct *work)
 	last = clp->cl_last_renewal;
 	now = jiffies;
 	/* Are we close to a lease timeout? */
-	if (time_after(now, last + lease/3))
+	//if (time_after(now, last + lease/3))
 		renew_flags |= NFS4_RENEW_TIMEOUT;
 	if (nfs_delegations_present(clp))
 		renew_flags |= NFS4_RENEW_DELEGATION_CB;
@@ -118,9 +118,9 @@ nfs4_schedule_state_renewal(struct nfs_client *clp)
 	spin_lock(&clp->cl_lock);
 	timeout = (2 * clp->cl_lease_time) / 3 + (long)clp->cl_last_renewal
 		- (long)jiffies;
-	if (timeout < 5 * HZ)
+//	if (timeout < 5 * HZ)
 		timeout = 5 * HZ;
-	dprintk("%s: requeueing work. Lease period = %ld\n",
+	printk("%s: requeueing work. Lease period = %ld\n",
 			__func__, (timeout + HZ - 1) / HZ);
 	mod_delayed_work(system_wq, &clp->cl_renewd, timeout);
 	set_bit(NFS_CS_RENEWD, &clp->cl_res_state);
diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c
index 1b207c9d5f9e..fa9fbfbb045a 100644
--- a/fs/nfs/nfs4state.c
+++ b/fs/nfs/nfs4state.c
@@ -2453,8 +2453,10 @@ static void nfs41_handle_cb_path_down(struct nfs_client *clp)
 void nfs41_handle_sequence_flag_errors(struct nfs_client *clp, u32 flags,
 		bool recovery)
 {
-	if (!flags)
+	if (!flags) {
+		printk("%s no flags\n", __func__);
 		return;
+	}
 
 	dprintk("%s: \"%s\" (client ID %llx) flags=0x%08x\n",
 		__func__, clp->cl_hostname, clp->cl_clientid, flags);
@@ -2476,8 +2478,12 @@ void nfs41_handle_sequence_flag_errors(struct nfs_client *clp, u32 flags,
 		nfs41_handle_some_state_revoked(clp);
 	if (flags & SEQ4_STATUS_LEASE_MOVED)
 		nfs4_schedule_lease_moved_recovery(clp);
-	if (flags & SEQ4_STATUS_RECALLABLE_STATE_REVOKED)
+	if (flags & SEQ4_STATUS_RECALLABLE_STATE_REVOKED) {
+		printk("%s detect SEQ4_STATUS_RECALLABLE_STATE_REVOKED\n", __func__);
 		nfs41_handle_recallable_state_revoked(clp);
+	} else {
+		printk("%s no SEQ4_STATUS_RECALLABLE_STATE_REVOKED\n", __func__);
+	}
 out_recovery:
 	if (flags & SEQ4_STATUS_BACKCHANNEL_FAULT)
 		nfs41_handle_backchannel_fault(clp);
diff --git a/fs/nfs_common/grace.c b/fs/nfs_common/grace.c
index 26f2a50eceac..bd22c4901833 100644
--- a/fs/nfs_common/grace.c
+++ b/fs/nfs_common/grace.c
@@ -31,9 +31,10 @@ locks_start_grace(struct net *net, struct lock_manager *lm)
 	struct list_head *grace_list = net_generic(net, grace_net_id);
 
 	spin_lock(&grace_lock);
-	if (list_empty(&lm->list))
+	if (list_empty(&lm->list)) {
+		printk("%s add lm %px to grace_list\n", __func__, lm);
 		list_add(&lm->list, grace_list);
-	else
+	} else
 		WARN(1, "double list_add attempt detected in net %x %s\n",
 		     net->ns.inum, (net == &init_net) ? "(init_net)" : "");
 	spin_unlock(&grace_lock);
@@ -55,6 +56,7 @@ void
 locks_end_grace(struct lock_manager *lm)
 {
 	spin_lock(&grace_lock);
+	printk("%s remove lm %px to grace_list\n", __func__, lm);
 	list_del_init(&lm->list);
 	spin_unlock(&grace_lock);
 }
diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 4bb5038d258c..2502b8fa7d79 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -1415,8 +1415,11 @@ nfsd4_run_cb_work(struct work_struct *work)
 	if (cb->cb_need_restart) {
 		cb->cb_need_restart = false;
 	} else {
-		if (cb->cb_ops && cb->cb_ops->prepare)
+		if (cb->cb_ops && cb->cb_ops->prepare) {
 			cb->cb_ops->prepare(cb);
+			printk("%s call prepare done, skip others\n", __func__);
+			return;
+		}
 	}
 
 	if (clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK)
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index a3a38bd487c7..a7f13b428855 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1345,6 +1345,7 @@ unhash_delegation_locked(struct nfs4_delegation *dp)
 	spin_lock(&fp->fi_lock);
 	list_del_init(&dp->dl_perclnt);
 	list_del_init(&dp->dl_recall_lru);
+	printk("%s remove dp %px from list\n", __func__, dp);
 	list_del_init(&dp->dl_perfile);
 	spin_unlock(&fp->fi_lock);
 	return true;
@@ -4060,8 +4061,10 @@ nfsd4_sequence(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	default:
 		seq->status_flags = 0;
 	}
-	if (!list_empty(&clp->cl_revoked))
+	if (!list_empty(&clp->cl_revoked)) {
+		printk("%s set SEQ4_STATUS_RECALLABLE_STATE_REVOKED for seq\n", __func__);
 		seq->status_flags |= SEQ4_STATUS_RECALLABLE_STATE_REVOKED;
+	}
 out_no_session:
 	if (conn)
 		free_conn(conn);
@@ -4857,6 +4860,7 @@ static void nfsd4_cb_recall_prepare(struct nfsd4_callback *cb)
 
 	block_delegations(&dp->dl_stid.sc_file->fi_fhandle);
 
+	printk("%s recall dp %px\n", __func__, dp);
 	/*
 	 * We can't do this in nfsd_break_deleg_cb because it is
 	 * already holding inode->i_lock.
@@ -4867,6 +4871,7 @@ static void nfsd4_cb_recall_prepare(struct nfsd4_callback *cb)
 	spin_lock(&state_lock);
 	if (delegation_hashed(dp) && dp->dl_time == 0) {
 		dp->dl_time = ktime_get_boottime_seconds();
+		printk("%s add dp %px to del_recall_lru\n", __func__, dp);
 		list_add_tail(&dp->dl_recall_lru, &nn->del_recall_lru);
 	}
 	spin_unlock(&state_lock);
@@ -4928,6 +4933,7 @@ static void nfsd_break_one_deleg(struct nfs4_delegation *dp)
 	 * flc_lock) we know the server hasn't removed the lease yet, and
 	 * we know it's safe to take a reference.
 	 */
+	printk("%s queue dl_recall\n", __func__);
 	refcount_inc(&dp->dl_stid.sc_count);
 	queued = nfsd4_run_cb(&dp->dl_recall);
 	WARN_ON_ONCE(!queued);
@@ -6162,6 +6168,7 @@ nfs4_laundromat(struct nfsd_net *nn)
 	spin_lock(&state_lock);
 	list_for_each_safe(pos, next, &nn->del_recall_lru) {
 		dp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);
+		printk("%s get dp %px from del_recall_lru\n", __func__, dp);
 		if (!state_expired(&lt, dp->dl_time))
 			break;
 		WARN_ON(!unhash_delegation_locked(dp));
@@ -6171,6 +6178,7 @@ nfs4_laundromat(struct nfsd_net *nn)
 	while (!list_empty(&reaplist)) {
 		dp = list_first_entry(&reaplist, struct nfs4_delegation,
 					dl_recall_lru);
+		printk("%s dp %px timeout\n", __func__, dp);
 		list_del_init(&dp->dl_recall_lru);
 		revoke_delegation(dp);
 	}
@@ -6780,6 +6788,7 @@ nfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		spin_unlock(&s->sc_lock);
 		dp = delegstateid(s);
 		list_del_init(&dp->dl_recall_lru);
+		printk("%s remove dp %px from list\n", __func__, dp);
 		spin_unlock(&cl->cl_lock);
 		nfs4_put_stid(s);
 		ret = nfs_ok;
