# 自旋锁
原始自旋锁不保证公平性，持锁者放锁后所有等锁者随机抢占；
2.6开始的票号自旋锁开始保证公平性，等锁者会有一个属于自己的tail值，依次增加，每次放锁会增加head值，当head值与当前等锁者的tail一致时当前等锁者才能获取锁，从而保证公平性，但这会有cache颠簸的问题；
3.15开始的MCS自旋锁通过链表的方式实现公平性。在锁被占用的情况下，等锁者会把指向自己的指针赋给当前持锁者或者自己前一位等锁者，当自己前一位的等锁者或者持锁者方式后会触发自己的持锁操作；
4.2开始的队列自旋锁通过类似的方式保证公平。持锁者占据锁的locked位，第一个等锁者占据锁的pending位，同时自旋持锁者占据的locked位。下一个等锁者会让锁的tail指向自己，后续的等锁者会让前一位等锁者的next指向自己。除第一个等锁者外，其他等锁者都在自己的locked位上自旋，等待前一位等锁者或持锁者唤醒，才能在锁的locked位上自旋。

MCS锁对比qspinlock
MCS锁：每个等待线程需要动态分配节点（包含自旋变量和指针）
qspinlock：使用每CPU的静态数组，避免动态分配
MCS锁：需要指针（64位系统至少8字节）+ 自旋变量
qspinlock：所有状态压缩到32位字中

# mutex锁
当一个进程尝试加锁（mutex_lock）时，首先会尝试快速路径直接获取锁；若失败（锁已被占用），则进入慢路径，此时会判断锁持有者是否正在其他CPU上执行，若是则通过osq机制进行自旋等待以优化性能，否则将自身加入等待队列（wait_list）并进入睡眠状态。在等锁期间，自旋的进程会持续检查锁状态，而睡眠的进程则等待被唤醒。当持有者解锁（mutex_unlock）时，若等待队列为空则直接释放锁；若有等待者，则根据是否设置了HANDOFF标志（用于解决自旋优化可能导致的公平性问题）决定：若无该标志则唤醒队列第一个等待者竞争锁，若设置了该标志则强制将锁移交给该等待者，确保其获得锁以避免饿死。整个流程中，锁的状态和等待者信息通过owner字段（低三位用作标志位）和受自旋锁（wait_lock）保护的等待队列来协同管理。

# 读写信号量
https://zhuanlan.zhihu.com/p/578510398

问题：写IO长时间卡住导致hungtask，预期是读写IO顺序占用读写信号量，但后来的读IO在尝试获取读信号量时没有调度出去，乐观自旋，在上一个IO释放读信号量的时候直接抢占读信号量，使得写IO仍然拿不到信号量

# RCU锁
