# 自旋锁
原始自旋锁不保证公平性，持锁者放锁后所有等锁者随机抢占；
2.6开始的票号自旋锁开始保证公平性，等锁者会有一个属于自己的tail值，依次增加，每次放锁会增加head值，当head值与当前等锁者的tail一致时当前等锁者才能获取锁，从而保证公平性，但这会有cache颠簸的问题；
3.15开始的MCS自旋锁通过链表的方式实现公平性。在锁被占用的情况下，等锁者会把指向自己的指针赋给当前持锁者或者自己前一位等锁者，当自己前一位的等锁者或者持锁者方式后会触发自己的持锁操作；
4.2开始的队列自旋锁通过类似的方式保证公平。持锁者占据锁的locked位，第一个等锁者占据锁的pending位，同时自旋持锁者占据的locked位。下一个等锁者会让锁的tail指向自己，后续的等锁者会让前一位等锁者的next指向自己。除第一个等锁者外，其他等锁者都在自己的locked位上自旋，等待前一位等锁者或持锁者唤醒，才能在锁的locked位上自旋。

MCS锁对比qspinlock
MCS锁：每个等待线程需要动态分配节点（包含自旋变量和指针）
qspinlock：使用每CPU的静态数组，避免动态分配
MCS锁：需要指针（64位系统至少8字节）+ 自旋变量
qspinlock：所有状态压缩到32位字中

# mutex锁

# 读写信号量
https://zhuanlan.zhihu.com/p/578510398

问题：写IO长时间卡住导致hungtask，预期是读写IO顺序占用读写信号量，但后来的读IO在尝试获取读信号量时没有调度出去，乐观自旋，在上一个IO释放读信号量的时候直接抢占读信号量，使得写IO仍然拿不到信号量

# RCU锁