# 设备模型概念

https://www.wowotech.net/device_model/13.html

Bus（总线）：Linux认为（可以参考include/linux/device.h中struct bus_type的注释），总线是CPU和一个或多个设备之间信息交互的通道。而为了方便设备模型的抽象，所有的设备都应连接到总线上（无论是CPU内部总线、虚拟的总线还是“platform Bus”）。
- 用于扫描连接在这个总线上的设备？ probe

Class（分类）：在Linux设备模型中，Class的概念非常类似面向对象程序设计中的Class（类），它主要是集合具有相似功能或属性的设备，这样就可以抽象出一套可以在多个设备之间共用的数据结构和接口函数。因而从属于相同Class的设备的驱动程序，就不再需要重复定义这些公共资源，直接从Class中继承即可。
- 抽象出多个设备的公用数据结构和函数

Device（设备）：抽象系统中所有的硬件设备，描述它的名字、属性、从属的Bus、从属的Class等信息。
- 具体的硬件设备描述

Device Driver（驱动）：Linux设备模型用Driver抽象硬件设备的驱动程序，它包含设备初始化、电源管理相关的接口实现。而Linux内核中的驱动开发，基本都围绕该抽象进行（实现所规定的接口函数）。
- 具体设备的一些驱动接口，初始化，电源管理等

# kobject

http://www.wowotech.net/device_model/kobject.html

kobject 是 Linux 内核中用于统一管理“内核对象”的基础设施。它提供了对象的生命周期管理、层级关系、名字命名、用户态可见性（sysfs 导出）以及事件通知（uevent）的通用机制。很多内核子系统都会把自己的对象“封装”进 kobject 或者通过 kobject 衔接到统一的对象模型里。

> struct device 本身内嵌了一个 struct kobject（dev->kobj），所以设备能出现在 /sys/devices/...
> 通过kobject可以便捷的查看设备状态和管理设备配置

Kobject是基本数据类型，每个Kobject都会在"/sys/“文件系统中以目录的形式出现
Ktype代表Kobject的属性操作集合
Kset是一个特殊的Kobject，它用来集合相似的Kobject

kobject用于构建设备树
sysfs目录下的文件用于查询设备状态或设置设备属性等，基于kernfs实现

每个Kobject都会在"/sys/“文件系统中以目录的形式出现
有sysfs接口的模块不一定是设备（例如cgroup）

```
// 创建kobject时创建sysfs目录
kobject_create_and_add
 kobject_create
  kobject_init // ktype:dynamic_kobj_ktype
 kobject_add
  kobject_add_varg
   kobject_add_internal
    create_dir

// kobject绑定属性（sysfs目录增加文件）
sysfs_create_file
 sysfs_create_file_ns
  sysfs_add_file_mode_ns
   __kernfs_create_file // name ops:dynamic_kobj_ktype.sysfs_ops:kobj_sysfs_ops

// 文件读取
kobj_attr_show
 demo_value_show // kattr->show 自定义 struct kobj_attribute demo_attr

举例：
[root@fedora ~]# insmod kobject_demo.ko
[   66.935376][  T884] kobject_demo: loading out-of-tree module taints kernel.
[root@fedora ~]# ls /sys/kernel/k
kexec_crash_loaded  kexec_loaded
kexec_crash_size    kobject_demo/
[root@fedora ~]# ls /sys/kernel/kobject_demo/
demo_value
[root@fedora ~]# cat /sys/kernel/kobject_demo/demo_value
Hello from kobject_demo!
[root@fedora ~]#
```

# uevent

http://www.wowotech.net/device_model/uevent.html

类似于nfsd的upcall/downcall机制？
类似于fuse的机制？


两个途径把事件上报到用户空间：
- 一种是通过kmod模块，直接调用用户空间的可执行文件；
- 另一种是通过netlink通信机制，将事件从内核空间传递给用户空间

netlink机制
uvent 是 Linux 内核用来向用户空间通知“设备/内核对象状态变化”的机制。它基于 kobject 框架：当内核中某个 kobject（如设备、驱动、类、总线等）发生创建、删除或属性变化时，可触发一个 uevent，内核通过 netlink 将事件发给用户空间程序（典型是 udev/systemd-udevd）去处理，比如创建设备节点、加载固件、运行规则脚本等。


# sysfs

https://www.wowotech.net/device_model/dm_sysfs.html


# platform设备
底层软件通过DTS/ACPI等方式告知内核存在哪些硬件，驱动模块加载时会把这些硬件对应的驱动注册到内核中，内核通过platform纵向匹配这些硬件设备和驱动，用这些已注册的驱动进行设备的初始化和使用
