# BIOS相关
esbc
    安全相关、校验BIOS、初始化tmp驱动等
sec
    初始化时钟，串口，ddr
pei
    配置MMU
dxe
    初始化各种驱动，网口驱动，sata驱动
bds
    bios的升级同步等

对于从核上下线、efuse读写等有一定安全要求的操作时，需通过SMC指令陷入EL3，调用TF的运行时服务(runtime service)实现
> 将参数保存到通用寄存器中，再通过smc命令陷入异常，进入TF的处理

esbc -(flash)-> bios -(hd)-> boot loader -(hd)-> linux

boot loader 将 initrd 加载到内存
内核基于 initrd 中的虚拟根文件系统加载真正的根文件系统，最后切换根目录？

linux 第一个 init 进程 --> 根据脚本配置启动各个进程(iscsid,lvm等)


# 中断相关
GIC规范(针对多核CPU管理中断)
    1-N
        中断信号发送到所有核后，有一个核处理，则撤销中断信号
    N-N
        中断信号发送到所有核后，要所有核处理后才会撤销中断信号

1) 设备唤醒CPU之后是立即跳转中断向量表指定的位置吗？如果不是，那么是什么时候才会跳转呢？
> 会被唤醒，但中断是关闭的，要打开中断后才能响应中断控制器

2) 已经跳转到中断服务函数开始执行代码，后续就会调用你注册的中断handle代码吗？如果不是，那中断服务函数做什么准备呢？而你注册的中断handle又会在什么时候才开始执行呢？
> 不一定，中断handle可能在下半部执行，中断服务函数通过软中断，tasklet，workqueue来异步执行

3) 假如register_thread_irq方式注册的threaded irq中调用msleep(1000)，睡眠1秒，请问系统此时会继续睡下去而没调度回来吗？因此导致msleep后续的操作没有执行
> 不会，这个睡眠的时候中断处理并没有完成，系统不会睡眠

4) 如果在注册的中断handle中把主要的操作都放在delayed work中，然后queue delayed work，work延时1秒执行，请问系统此时会继续睡下去而没调度delayed work吗？因此导致delayed work中的操作没有执行呢？
有可能

5) 如果4)成立的话，我们该如何编程避免这个问题呢？
通过combined_event_count计数控制系统不睡眠


中断下半部：
软中断、workqueue、tasklet


acpi

MSI/MSI-X