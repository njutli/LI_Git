# 启动相关
## BIOS
esbc
    安全相关、校验BIOS、初始化tmp驱动等
sec
    初始化时钟，串口，ddr
pei
    配置MMU
dxe
    初始化各种驱动，网口驱动，sata驱动
bds
    bios的升级同步等

对于从核上下线、efuse读写等有一定安全要求的操作时，需通过SMC指令陷入EL3，调用TF的运行时服务(runtime service)实现
> 将参数保存到通用寄存器中，再通过smc命令陷入异常，进入TF的处理

esbc -(flash)-> bios -(hd)-> boot loader -(hd)-> linux

## boot loader
    加载用来识别文件系统的文件，找到/boot目录
    加载内核
    加载 initrd
    基于内核和initrd挂载真正的根文件系统，最后切换根目录
    运行 init 进程 --> 根据脚本配置启动各个进程(iscsid,lvm等)


# 中断相关
GIC规范(针对多核CPU管理中断)
    1-N
        中断信号发送到所有核后，有一个核处理，则撤销中断信号
    N-N
        中断信号发送到所有核后，要所有核处理后才会撤销中断信号

1) 设备唤醒CPU之后是立即跳转中断向量表指定的位置吗？如果不是，那么是什么时候才会跳转呢？
> 会被唤醒，但中断是关闭的，要打开中断后才能响应中断控制器

2) 已经跳转到中断服务函数开始执行代码，后续就会调用你注册的中断handle代码吗？如果不是，那中断服务函数做什么准备呢？而你注册的中断handle又会在什么时候才开始执行呢？
> 不一定，中断handle可能在下半部执行，中断服务函数通过软中断，tasklet，workqueue来异步执行

3) 假如register_thread_irq方式注册的threaded irq中调用msleep(1000)，睡眠1秒，请问系统此时会继续睡下去而没调度回来吗？因此导致msleep后续的操作没有执行
> 不会，这个睡眠的时候中断处理并没有完成，系统不会睡眠

4) 如果在注册的中断handle中把主要的操作都放在delayed work中，然后queue delayed work，work延时1秒执行，请问系统此时会继续睡下去而没调度delayed work吗？因此导致delayed work中的操作没有执行呢？
有可能

5) 如果4)成立的话，我们该如何编程避免这个问题呢？
通过combined_event_count计数控制系统不睡眠

## 中断处理过程（软中断）
1.  **响应硬中断**：硬件设备产生中断信号，CPU暂停当前任务，**跳转到对应的硬中断处理程序**。该程序会进行**最紧急的硬件操作**（如读取网卡数据到内存），然后根据中断类型，**设置或“唤醒”对应的软中断状态标志**（如`NET_RX_SOFTIRQ`），表示有任务需要延迟处理。随后，硬中断服务例程快速退出。
硬件中断会通过中断控制器传递给CPU，如GIC。
GIC会有中断屏蔽，中断排序的功能，也会根据配置决定什么时候撤销中断信号。如1-N，只要有CPU响应中断就撤销，如N-N，需要所有CPU响应中断才会撤销
2.  **触发与检查**：在硬中断处理程序退出后、返回被中断的代码前，这是一个**关键检查点**。内核会检查当前CPU的`softirq_pending`位图。如果发现有软中断被设置（即有待处理任务），则进入软中断处理流程。
3.  **执行软中断**：
    *   **立即执行**：在检查点，如果**待处理的软中断数量不多且未嵌套**，内核会**直接调用`__do_softirq()`函数**，在当前的中断上下文中依次执行所有已设置的软中断处理函数（如网络收发包`net_rx_action`）。
    *   **延迟唤醒**：如果在处理软中断过程中，其**被频繁触发或执行时间过长**（防止一个CPU上的软中断独占资源），内核会退出立即执行模式，**唤醒一个专用的内核线程`ksoftirqd/`**（每个CPU一个）。该线程在进程上下文中以较低的优先级**异步处理**累积的软中断任务。
4.  **执行完毕**：软中断处理函数执行完所有任务后，会**清除对应的状态标志**。内核最终**返回到被硬中断打断的现场**（可能是用户态或内核态），整个过程结束。

## tasklet
tasklet是一种特殊的软中断，各个模块可以添加自己的task，但软中断入口是同一个。
相比较软中断，tasklet更灵活，各个模块可以动态添加，但延迟高，在有多个task的情况下，当前模块的task可能要等前面的task执行完才能执行

## 内核抢占
内核抢占的开启与关闭，核心区别在于 是否允许一个正在内核态执行的进程被更高优先级的进程强制打断并切换


中断下半部：
软中断、workqueue、tasklet

软中断和tasklet在负载轻的情况下运行在中断上下文，负载重的情况下可能由ksoftirqd运行在进程上下文，工作队列运行在进程上下文

acpi

MSI/MSI-X