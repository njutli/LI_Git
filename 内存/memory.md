1. ZONE_DMA、ZONE_NORMAL、ZONE_HIGHMEM 的物理地址范围是固定的吗？
答： 是的，这些区域的物理地址范围在系统启动时就固定了（如 ZONE_DMA: 0-16MB, ZONE_NORMAL: 16MB-896MB, ZONE_HIGHMEM: 896MB以上），但这些划分是为了兼容硬件限制和内核地址空间映射，64位系统通常不需要 ZONE_HIGHMEM。

2. 为什么 ZONE_NORMAL 只有 896MB？为什么不能更大？
答： 因为 32位 Linux 内核需要在自己的 1GB 虚拟地址空间（0xC0000000-0xFFFFFFFF）中直接映射物理内存，除去内核代码、数据结构、vmalloc 等预留空间后，只剩 896MB 可用于直接映射物理内存。

3. 那内核态程序是不是也只能使用 1GB 的虚拟地址？
答： 不是，内核可以通过 vmalloc、kmap 等机制访问超过 1GB 的物理内存，但直接映射（线性映射）确实只有约 896MB，访问高端内存需要临时建立映射。

4. 为什么 0-16MB 是 ZONE_DMA？
答： 因为古老的 ISA 总线 DMA 控制器只能访问 24位地址（0-16MB），为了兼容这些老硬件，内核将这段内存单独划分为 ZONE_DMA 区域。

5. 现代硬件还需要 ZONE_DMA 吗？
答： 现代硬件通常不需要，因为 PCI/PCIe 设备支持 32位甚至64位地址，但内核保留 ZONE_DMA 是为了向后兼容和支持某些嵌入式系统中的特殊硬件。

6. 用户态程序能访问 0xC0000000-0xFFFFFFFF 这段虚拟地址吗？
答： 不能，虽然这段地址在页表中有映射，但页表项的 user 位为 0，CPU 硬件会阻止用户态（Ring 3）访问，尝试访问会触发段错误（SIGSEGV）。

7. 既然用户态不能访问 0xC0000000 以上的地址，那这段虚拟地址的定义划分有什么意义呢？
答： 意义巨大！进程通过系统调用陷入内核时，只提升特权级（Ring 3 → Ring 0）而无需切换页表，内核可直接访问内核空间（0xC0000000+）和用户空间（0x00000000+），避免了页表切换和 TLB 刷新，使系统调用性能提升 5-10 倍。

8. 用户态进程通过 malloc 多次分配堆内存，每个堆内存对应的虚拟地址是不断增大的吗？
答： 不一定，小块内存（< 128KB）使用 brk/sbrk 在堆区分配，地址通常递增，但 free 后会复用；大块内存（≥ 128KB）使用 mmap 分配，地址通常递减；具体模式还受内存复用和地址空间随机化（ASLR）影响。

9. 栈对应的物理内存是怎么分配的？
答： 栈的虚拟地址空间在进程启动时预留（如 8MB），但物理内存采用按需分配（Demand Paging）：声明栈变量时只预留虚拟地址，第一次访问时触发缺页中断才分配物理页框，大大提高了内存利用率。
