wb_workfn

// .write_iter
nfs_file_write
 generic_perform_write
  nfs_write_begin // a_ops->write_begin
   __filemap_get_folio // 根据 pos 获取folio
  copy_folio_from_iter_atomic // 用户态数据拷贝到 folio 中
  nfs_write_end // a_ops->write_end
   nfs_update_folio
    nfs_writepage_setup
     nfs_setup_write_request
	  nfs_try_to_update_request
	   nfs_lock_and_join_requests
	    nfs_folio_find_head_request
		 folio_test_private // 第一次没有对应的 nfs_page ， folio->private 为空
	  nfs_page_create_from_folio
	   nfs_page_create
	    nfs_page_alloc // 分配初始化 nfs_page ，初始计数为1
	   nfs_page_assign_folio // nfs_page 绑定 folio
	    req->wb_folio = folio
		folio_get
	   nfs_page_group_init // 初始化 page group，即以当前 nfs_page 为起始的一组 nfs_page
	    req->wb_head = req // 头指向自己
		req->wb_this_page = req // 下一个指向自己
	  nfs_inode_add_request // folio 绑定 nfs_page
	   folio_set_private
	   folio->private = req
	 nfs_grow_file // 更新文件大小
	 nfs_mark_uptodate // 将 folio 置为 uptodate
	 nfs_mark_request_dirty // 将 folio 置为 dirty

// 后台回写触发
nfs_writepages
 nfs_pageio_init_write // 初始化 nfs_pageio_descriptor
  nfs_pageio_init
   desc->pg_completion_ops = nfs_async_write_completion_ops
 writeback_iter
  writeback_get_folio // 获取待处理的 folio
 nfs_do_writepage
  nfs_lock_and_join_requests
   nfs_folio_find_head_request
    folio_test_private // 当前 folio->private 不为空
  nfs_pageio_add_request
   nfs_pageio_setup_mirroring // 分配 nfs_pgio_mirror
 nfs_pageio_complete
  nfs_pageio_complete_mirror
   nfs_pageio_doio
    nfs_generic_pg_pgios
	 nfs_initiate_pgio
	  nfs_initiate_write
	   nfs_proc_write_setup // NFSPROC_WRITE
	   // 请求类型是 NFSPROC_WRITE ，rpc_call_ops 是 nfs_pgio_common_ops

// 请求完成后
nfs_pgio_release
 nfs_write_completion // hdr->completion_ops->completion
  nfs_page_end_writeback
   nfs_unlock_request


	  nfs_try_to_update_request
	   nfs_lock_and_join_requests
      nfs_page_create_from_folio
       nfs_page_create
        nfs_page_alloc



关键数据结构体 nfs_pageio_descriptor
req 是怎么生成的，怎么和 nfs_pageio_descriptor 里的链表关联的


1377 static const struct nfs_pgio_completion_ops nfs_async_write_completion_ops = {
1378         .init_hdr = nfs_async_write_init,
1379         .error_cleanup = nfs_async_write_error,
1380         .completion = nfs_write_completion,
1381         .reschedule_io = nfs_async_write_reschedule_io,
1382 };


// NFSPROC4_CLNT_COMMIT
nfs_commit_inode
 __nfs_commit_inode
  nfs_generic_commit_list
   nfs_commit_list
    nfs_init_commit // nfs_commit_ops
   nfs_initiate_commit

nfs_commit_release
 nfs_write_completion // data->completion_ops->completion
  nfs_inode_remove_request
   folio->private = NULL
   nfs_release_request
   ...
    nfs_page_group_destroy
     nfs_free_request
	  nfs_page_free
	   kmem_cache_free // nfs_page_cachep

// .write_iter
nfs_file_write
 generic_perform_write
  nfs_write_begin
   __filemap_get_folio // 根据 pos 获取folio
  nfs_write_end // a_ops->write_end
   nfs_update_folio
    nfs_writepage_setup
     nfs_setup_write_request
	  nfs_try_to_update_request
	   nfs_lock_and_join_requests
      nfs_page_create_from_folio
       nfs_page_create
        nfs_page_alloc

// .writepages
nfs_writepages
 nfs_pageio_complete
  nfs_pageio_complete_mirror
   nfs_pageio_doio
    nfs_generic_pg_pgios
	 nfs_initiate_pgio
	  nfs_initiate_write
	   nfs_proc_write_setup // NFSPROC_WRITE
	   ...
	   nfs4_xdr_enc_write
	    encode_sequence
		encode_putfh
		encode_write // OP_WRITE
		 args->stateid
		 args->offset
		 args->stable
		 args->count
		 args->pages
		 args->pgbase
	   nfs4_xdr_dec_write


客户端写：
1、数据写入
先调 nfs_file_write (write_iter回调)，数据写入buffer
2、数据同步
2.1 通过 nfs_commit_inode (fsync等操作触发)，发送 NFSPROC4_CLNT_COMMIT 请求，服务端通过 nfsd4_commit 处理commit请求，如果nfsd配置了sync，那么数据就直接落盘
2.2 通过 nfs_writepages (后台回写等操作触发)， 发送 NFSPROC4_CLNT_WRITE 请求

commit a7d42ddb3099727f58366fa006f850a219cce6c8
Author: Weston Andros Adamson <dros@primarydata.com>
Date:   Fri Sep 19 10:55:07 2014 -0400

    nfs: add mirroring support to pgio layer

    This patch adds mirrored write support to the pgio layer. The default
    is to use one mirror, but pgio callers may define callbacks to change
    this to any value up to the (arbitrarily selected) limit of 16.

    The basic idea is to break out members of nfs_pageio_descriptor that cannot
    be shared between mirrored DSes and put them in a new structure.

    Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
